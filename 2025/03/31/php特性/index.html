<p>其中笔记多为查询ai获得</p>
<p>ai直接解释不清楚的  为自行查找并总结</p>
<h2 id="strops"><a href="#strops" class="headerlink" title="strops()"></a>strops()</h2><p><code>strpos()</code> 是 <strong>PHP 用来查找字符串</strong> 的函数，它用于查找 <strong>某个字符串</strong> 在 <strong>另一个字符串</strong> 中 <strong>首次出现的位置</strong>。</p>
<pre><code>    if (strpos($xdmtql, &#39;sys nb&#39;) !== false) &#123; 
        echo &#39;flag&#123;*******&#125;&#39;;
    &#125; else &#123; 
        echo &#39;true .swp file?&#39;;
    &#125;
</code></pre>
<p>strops函数匹配上传的参数里有sys nb</p>
<ul>
<li><p>如果 <code>$xdmtql</code> <strong>不匹配</strong> <code>/sys.*nb/</code>（即 <code>sys</code> 和 <code>nb</code> 不能被任何字符隔开，除非是空格）</p>
</li>
<li><p>如果 <code>$xdmtql</code> 里面有 “sys nb”，输出 flag{*******}<code>（获取 flag）</code></p>
</li>
<li><p><code>否则，输出 </code>“true .swp file?”&#96;。</p>
</li>
</ul>
<h2 id="preg-match"><a href="#preg-match" class="headerlink" title="preg_match()"></a><strong>preg_match()</strong></h2><p><code>preg_match(&#39;/^\W+$/&#39;, $v3)</code>：这行代码检查<code>v3</code>是否只包含非字母数字字符（即不是字母、数字或下划线）。这样可以确保<code>v3</code>是一个运算符或其他特殊字符。</p>
<p><strong>^\W+$</strong>   代表不能是字母 数字 下划线</p>
<p>preg_match函数处理的字符长度有限，如果超过这个长度就会返回false也就是没有匹配到。</p>
<p>必要时可以通过回溯  即让字符长度超长  使preg_match返回false来绕过该函数</p>
<p>PHP <strong>默认的 pcre.backtrack_limit 是 1,000,000（1MB）</strong>，即 <code>preg_match()</code> <strong>最多检查 1MB 的内容</strong>，超出会 <strong>直接返回 <code>false</code></strong>，不会报错。  （有一些用.+?之类的了   不够就继续加）</p>
<p><strong>php代码</strong></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">str_repeat</span>(<span class="string">&#x27;very&#x27;</span>,<span class="string">&#x27;10000000&#x27;</span>).<span class="string">&#x27;36Dctfshow&#x27;</span>;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str_repeat(&#x27;very&#x27;, &#x27;250000&#x27;)</span><br></pre></td></tr></table></figure>

<ul>
<li>这会重复字符串 <code>&#39;very&#39;</code> <strong>250000 次</strong>，生成一个非常长的字符串。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x27;36Dctfshow&#x27;</span><br></pre></td></tr></table></figure>

<ul>
<li>在上面重复的 <code>&#39;very&#39;</code> 250000 次的字符串后面，拼接 <code>&#39;36Dctfshow&#39;</code>。</li>
</ul>
<p>绕过示例代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">data = &#123;&quot;xdmtql&quot;: &quot;sys nb&quot; + &quot;a&quot; * 1000000&#125;</span><br><span class="line">res = requests.post(&#x27;http://f9546f10-7706-46f8-a4ce-2e73a4e9ca62.www.polarctf.com:8090/index.php&#x27;, data=data, allow_redirects=False)</span><br><span class="line">print(res.content)</span><br></pre></td></tr></table></figure>

<h2 id="1️⃣-data-data"><a href="#1️⃣-data-data" class="headerlink" title="1️⃣ data=data"></a><strong>1️⃣ <code>data=data</code></strong></h2><ul>
<li><p><strong>作用</strong>：指定 <strong>要发送的 POST 数据</strong>，通常是一个 <strong>字典</strong> (<code>dict</code>) 或 <strong>字符串</strong> (<code>str</code>)。</p>
</li>
<li><p>格式</p>
<ul>
<li><p>发送 </p>
<p>表单数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;&quot;username&quot;: &quot;admin&quot;, &quot;password&quot;: &quot;123456&quot;&#125;</span><br><span class="line">requests.post(url, data=data)</span><br></pre></td></tr></table></figure>

<p>这会 </p>
<p>以 <code>application/x-www-form-urlencoded</code> 形式发送</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username=admin&amp;password=123456</span><br></pre></td></tr></table></figure>
</li>
<li><p>发送 </p>
<p>纯文本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requests.post(url, data=&quot;raw_text_data&quot;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h2 id="2️⃣-allow-redirects-False"><a href="#2️⃣-allow-redirects-False" class="headerlink" title="2️⃣ allow_redirects=False"></a><strong>2️⃣ <code>allow_redirects=False</code></strong></h2><ul>
<li><p><strong>作用</strong>：<strong>禁用 HTTP 自动跳转</strong>（默认 <code>True</code>）。</p>
</li>
<li><p><strong>为什么要关掉自动跳转？</strong></p>
<ul>
<li>有些 CTF 服务器如果 <strong>验证失败</strong>，会 <strong>302 重定向</strong> 到错误页面。</li>
<li>如果 <code>allow_redirects=True</code>（默认），requests <strong>会自动跟随跳转</strong>，你可能看不到 <strong>原始返回内容</strong>。</li>
<li>但如果 <code>allow_redirects=False</code>，你可以手动检查 <strong>是否返回了 302 状态码</strong>。</li>
</ul>
</li>
<li><p><strong>示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res = requests.post(&quot;http://example.com/login&quot;, data=&#123;&quot;user&quot;: &quot;admin&quot;&#125;, allow_redirects=False)</span><br><span class="line">print(res.status_code)  # 可能返回 302</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果 <code>res.status_code == 302</code>，说明服务器 <strong>想跳转</strong>。</p>
</li>
<li><p>你可以查看 </p>
<p>Location 头</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(res.headers.get(&quot;Location&quot;))  # 可能是 &quot;/error&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="文件上传靶场出现函数"><a href="#文件上传靶场出现函数" class="headerlink" title="文件上传靶场出现函数"></a>文件上传靶场出现函数</h2><p><img src="C:\Users\csdd\AppData\Roaming\Typora\typora-user-images\image-20250316105250599.png" alt="image-20250316105250599"></p>
<p><strong>trim</strong> 函数能够对上传文件的空格，换行符(%0a %0b %0d %20 %09)等多余字符进行删除，返回修改后的字符，</p>
<p><strong>deldot</strong>删除文件名末尾的点，都是对文件名进行优化。<br> <strong>strrchr()</strong> 函数能够查找子字符串在字符串最后一次出现的位置（r即最右的值），返回该字符串到整体字符串结尾的所有字符。这里是返回上传文件的最后一个后缀名。<br> <strong>strtolower()</strong> 函数能够将这最后一个后缀名全部转换为小写。<br> <strong>str_ireplace()</strong> 函数能够实现字符串的部分替换，它的三个参数分别为‘查找值’；‘替换值’；‘待查找字符串’<br> <strong>in_array()</strong> 就是在数组中搜索值，第一个参数为搜索值，第二个参数为搜索范围<br> 除去第一个条件判断是否有上传路径，通过提示和查看源码可以发现，服务器设置了一个黑名单<br> <strong>[‘tmp_name’]</strong> 是服务器端储存的临时文件名<br> <strong>date()</strong> 能够格式化本地日期和时间，并返回已格式化的日期字符串，具体返回值与给定format值有关。<br> <strong>move_uploaded_file()</strong> 即将文件移至相应位置。</p>
<h3 id="intval-函数（https-blog-csdn-net-wangyuxiang946-article-details-131156104）"><a href="#intval-函数（https-blog-csdn-net-wangyuxiang946-article-details-131156104）" class="headerlink" title="intval()函数（https://blog.csdn.net/wangyuxiang946/article/details/131156104）"></a>intval()函数（<a href="https://blog.csdn.net/wangyuxiang946/article/details/131156104%EF%BC%89">https://blog.csdn.net/wangyuxiang946/article/details/131156104）</a></h3><pre><code>一、进制自动转换
二、转换数组
三、转换小数
四、转换字符串
五、取反~
六、算数运算符
七、浮点数精度缺失问题
三、intval()绕过思路
</code></pre>
<p>intval() 函数可以获取变量的「整数值」。常用于强制类型转换。</p>
<p>语法</p>
<p>int intval( $var, $base )</p>
<p>参数</p>
<pre><code>$var：需要转换成 integer 的「变量」
$base：转换所使用的「进制」
</code></pre>
<p>返回值</p>
<p>返回值为 integer 类型，可能是 0 或 1 或 其他integer 值。</p>
<pre><code>0：失败 或 空array 返回 0
1：非空array 返回 1
其他integer值：成功时 返回 $var 的 integer 值。
</code></pre>
<p>返回值的「最大值」取决于系统</p>
<pre><code>32 位系统（-2147483648 到 2147483647）
64 位系统（-9223372036854775808到9223372036854775807）
</code></pre>
<p>一、进制自动转换</p>
<p>第二个参数 $base 允许为空。</p>
<p>当 base 为空时，默认值是 0，会根据 $var 的格式来调整转换的进制。</p>
<pre><code>如果 $var 以 0 开头，就使用 8进制
如果 $var 以0x开头，就使用 16进制
否则，就使用 10进制
</code></pre>
<p>实例：</p>
<p><strong>10的 8进制是12</strong></p>
<p>var_dump(intval(012));</p>
<p><strong>10的 16进制是A</strong></p>
<p>var_dump(intval(0xA));</p>
<p><strong>10的 10进制是10</strong></p>
<p>var_dump(intval(10));</p>
<p>输出：</p>
<p>int(10)<br>int(10)<br>int(10)</p>
<p>绕过思路：当某个数字被过滤时，可以使用它的 8进制&#x2F;16进制来绕过。</p>
<p>二、转换数组</p>
<p>intval() 转换数组类型时，不关心数组中的内容，只判断数组中有没有元素。</p>
<pre><code>「空数组」返回 0
「非空数组」返回 1
</code></pre>
<p>实例：</p>
<p>var_dump(intval(array()));<br>var_dump(intval(array(3,2)));</p>
<p>输出：</p>
<p>int(0)<br>int(1)</p>
<p>如果传入的 $var是数组中的某个值时，则当做变量来转换，而不是当做数组类型。</p>
<p>实例：</p>
<p>$arr1 &#x3D; array(8,6);</p>
<p>var_dump(intval($arr1[0]));</p>
<p>输出：</p>
<p>int(8)</p>
<p>绕过思路：对于弱比较（a&#x3D;&#x3D;b），可以给a、b两个参数传入空数组，使弱比较为true。</p>
<p>三、转换小数</p>
<p>intval() 转换小数类型时，只返回个位数，不遵循四舍五入的原则。</p>
<p>实例：</p>
<p>var_dump(intval(12));<br>var_dump(intval(1.2));<br>var_dump(intval(1.9));</p>
<p>输出：</p>
<p>int(12)<br>int(1)<br>int(1)</p>
<p>绕过思路：当某个数字被过滤时，可以给它增加小数位来绕过。</p>
<p>四、转换字符串</p>
<p>intval() 转换字符串类型时，会判断字符串是否以数字开头</p>
<pre><code>如果以数字开头，就返回1个或多个连续的数字
如果以字母开头，就返回0
</code></pre>
<p>单双引号对转换结果没有影响，并且 0 或 0x 开头也只会当做普通字符串处理。</p>
<p>实例：</p>
<p>var_dump(intval(‘12abc’));<br>var_dump(intval(“12abc”));<br>var_dump(intval(‘abc123’));<br>var_dump(intval(‘1a2b3c’));<br>var_dump(intval(‘0101’));<br>var_dump(intval(“0x2b”));</p>
<p>输出：</p>
<p>int(12)<br>int(12)<br>int(0)<br>int(1)<br>int(101)<br>int(0)</p>
<p>五、取反~</p>
<p>intval() 函数支持一些特殊符号的，比如~取反。</p>
<p>实例：</p>
<p>var_dump(intval(~10));<br>var_dump(intval(~~10));</p>
<p>输出：</p>
<p>int(-11)<br>int(10)</p>
<p>绕过思路：当某个数字被过滤时，可以两次取反来绕过。</p>
<p>六、算数运算符</p>
<p>intval() 函数支持算数运算符，如果传入的 $var参数包含算数运算符，会先运算，再对运算结果进行转换。</p>
<p>实例：</p>
<p>var_dump(intval(5*5));<br>var_dump(intval(5+5));<br>var_dump(intval(05+5));</p>
<p>输出：</p>
<p>int(25)<br>int(10)<br>int(10)</p>
<p>绕过思路：当某个数字被过滤时，可以使用算数运算符绕过。</p>
<p>七、浮点数精度缺失问题</p>
<p>由于PHP中的浮点数是「弱类型」，存在「精度丢失」的问题，在转换时可能会出现意料之外的情况。</p>
<p>比如下面这个案例，第一个输出34正常，第二个以为会输出58，结果输出了57。</p>
<p>实例：</p>
<p>var_dump(intval(0.34<em>100.0));<br>var_dump(intval(0.58</em>100.0));</p>
<p>输出：</p>
<p>int(34)<br>int(57)</p>
<p>三、intval()绕过思路</p>
<p>最后汇总一下intval()函数漏洞的绕过思路：</p>
<p>1）当某个数字被过滤时，可以使用它的 8进制&#x2F;16进制来绕过；比如过滤10，就用012（八进制）或0xA（十六进制）。<br>2）对于弱比较（a&#x3D;&#x3D;b），可以给a、b两个参数传入空数组，使弱比较为true。<br>3）当某个数字被过滤时，可以给它增加小数位来绕过；比如过滤3，就用3.1。<br>4）当某个数字被过滤时，可以给它拼接字符串来绕过；比如过滤3，就用3ab。（GET请求的参数会自动拼接单引号）<br>5）当某个数字被过滤时，可以两次取反来绕过；比如过滤10，就用~~10。<br>6）当某个数字被过滤时，可以使用算数运算符绕过；比如过滤10，就用 5+5 或 2*5</p>
<p>intval(“+010574”, 0)&#x3D;&#x3D;4476 True。  有时会用+号绕过  或者url编码的%2b</p>
<h3 id="ctype-alpha"><a href="#ctype-alpha" class="headerlink" title="ctype_alpha()"></a>ctype_alpha()</h3><p><code>ctype_alpha()</code> <strong>只检测字母</strong>，不会检查数字和符号。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for ($i=0;$i&lt;strlen($emp);$i++)&#123;</span><br><span class="line">    if (ctype_alpha($emp[$i]))&#123;</span><br><span class="line">        die(&quot;你不是hacker？那请去外场等候！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如这个就是检查$emp里有没有字母  如果有字母终止下面代码的执行 执行die 输出：你不是hacker？那请去外场等候！</p>
<h3 id="stripos"><a href="#stripos" class="headerlink" title="stripos()"></a>stripos()</h3><p><code>stripos($try, &quot;HACKER&quot;)</code> </p>
<p><strong><code>stripos()</code></strong> 是 PHP 的一个字符串查找函数，作用是<strong>查找子字符串在字符串中首次出现的位置</strong>，<strong>不区分大小写</strong>。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a><strong>语法</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stripos(string $haystack, string $needle, int $offset = 0): int|false</span><br></pre></td></tr></table></figure>

<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a><strong>参数</strong></h4><ul>
<li><code>$haystack</code>（必填）：要搜索的字符串。</li>
<li><code>$needle</code>（必填）：要查找的子字符串。</li>
<li><code>$offset</code>（可选）：从哪个位置开始查找，默认为 <code>0</code>。</li>
</ul>
<h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a><strong>返回值</strong></h4><ul>
<li><strong>如果找到</strong> <code>needle</code>，返回它的<strong>索引位置</strong>（从 <code>0</code> 开始）。</li>
<li><strong>如果找不到</strong>，返回 <code>false</code>。</li>
</ul>
<h3 id="SqlFileObject"><a href="#SqlFileObject" class="headerlink" title="SqlFileObject"></a>SqlFileObject</h3><p><code>SplFileObject</code> 是 PHP 的一个内置类，它是 <strong>Standard PHP Library (SPL)</strong> 的一部分，专门用于 <strong>处理文件的读取、写入</strong> 和 <strong>文件信息获取</strong>。通过 <code>SplFileObject</code>，可以轻松地以面向对象的方式操作文件，提供了一些常用的文件操作方法。</p>
<h2 id="SplFileObject-类的常用方法"><a href="#SplFileObject-类的常用方法" class="headerlink" title="SplFileObject 类的常用方法"></a><strong><code>SplFileObject</code> 类的常用方法</strong></h2><h3 id="1-打开文件"><a href="#1-打开文件" class="headerlink" title="1. 打开文件"></a>1. <strong>打开文件</strong></h3><p>可以使用 <code>__construct()</code> 来打开一个文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$file = new SplFileObject(&#x27;path/to/file.txt&#x27;, &#x27;r&#x27;);  // 只读模式打开文件</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第二个参数是模式，类似于 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fopen()</span><br></pre></td></tr></table></figure>

<p>，常见的模式有：</p>
<ul>
<li><code>&#39;r&#39;</code>: 只读</li>
<li><code>&#39;w&#39;</code>: 写入</li>
<li><code>&#39;a&#39;</code>: 追加</li>
<li><code>&#39;r+&#39;</code>: 读写</li>
</ul>
</li>
</ul>
<h3 id="2-逐行读取文件"><a href="#2-逐行读取文件" class="headerlink" title="2. 逐行读取文件"></a>2. <strong>逐行读取文件</strong></h3><p><code>SplFileObject</code> 可以像数组一样访问文件内容，也可以逐行读取：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$file = new SplFileObject(&#x27;path/to/file.txt&#x27;);</span><br><span class="line">while (!$file-&gt;eof()) &#123;  // eof() 方法检查是否已到文件末尾</span><br><span class="line">    echo $file-&gt;fgets();  // 逐行读取</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-获取当前行"><a href="#3-获取当前行" class="headerlink" title="3. 获取当前行"></a>3. <strong>获取当前行</strong></h3><p>可以通过 <code>current()</code> 方法获取当前行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $file-&gt;current();  // 获取当前行</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>获取文件信息</strong></li>
</ol>
<ul>
<li><p>文件大小：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $file-&gt;getSize();  // 获取文件大小</span><br></pre></td></tr></table></figure>


</li>
<li><p>文件路径：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $file-&gt;getRealPath();  // 获取文件的绝对路径</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-写入文件"><a href="#5-写入文件" class="headerlink" title="5. 写入文件"></a>5. <strong>写入文件</strong></h3><p>通过 <code>SplFileObject</code> 可以轻松写入文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$file = new SplFileObject(&#x27;path/to/file.txt&#x27;, &#x27;w&#x27;);  // 写入模式打开文件</span><br><span class="line">$file-&gt;fwrite(&quot;Hello, world!&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="6-读取文件的特定行"><a href="#6-读取文件的特定行" class="headerlink" title="6. 读取文件的特定行"></a>6. <strong>读取文件的特定行</strong></h3><p>使用 <code>seek()</code> 方法可以将指针移动到文件中的特定行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$file-&gt;seek(2);  // 移动到第三行</span><br><span class="line">echo $file-&gt;current();  // 打印第三行内容</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="结合-php-filter-实现文件内容读取"><a href="#结合-php-filter-实现文件内容读取" class="headerlink" title="结合 php://filter 实现文件内容读取"></a><strong>结合 <code>php://filter</code> 实现文件内容读取</strong></h2><p><code>SplFileObject</code> 的强大之处在于它可以与 PHP 的流过滤器（如 <code>php://filter</code>）结合使用。这可以让你对文件内容进行特殊的处理，如编码转换。</p>
<p>例如，利用 <code>php://filter</code> 读取文件并将内容 <strong>base64 编码</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$file = new SplFileObject(&#x27;php://filter/read=convert.base64-encode/resource=flag.php&#x27;);</span><br><span class="line">echo $file-&gt;fgets();  // 输出 base64 编码的文件内容</span><br></pre></td></tr></table></figure>

<ul>
<li><code>php://filter</code> 是 PHP 的一个特殊流协议，它允许你在读取文件时应用过滤器。<code>convert.base64-encode</code> 是一个过滤器，它会将文件内容编码成 base64。</li>
<li>通过这种方式，可以避免直接输出文件内容，而是输出其编码后的内容。</li>
</ul>
<h3 id="fgets"><a href="#fgets" class="headerlink" title="fgets"></a>fgets</h3><p><code>fgets()</code> 是 PHP 中的一个文件操作函数，用于 <strong>从文件指针</strong> 读取一行内容。它会 <strong>逐行读取文件</strong>，直到遇到 <strong>换行符</strong>（<code>\n</code>）或 <strong>文件末尾</strong>（EOF）。这是一个常用的文件读取函数，特别是在需要逐行处理文件内容时。</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a><strong>基本用法</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$file = fopen(&#x27;path/to/file.txt&#x27;, &#x27;r&#x27;); // 打开文件以只读模式</span><br><span class="line">if ($file) &#123;</span><br><span class="line">    while (($line = fgets($file)) !== false) &#123;</span><br><span class="line">        echo $line;  // 输出每一行</span><br><span class="line">    &#125;</span><br><span class="line">    fclose($file);  // 关闭文件</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    echo &quot;无法打开文件&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a><strong>参数说明</strong></h3><p><code>fgets()</code> 函数有两个参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fgets($file, $length);</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>$file</strong>：一个有效的文件指针（由 <code>fopen()</code> 或 <code>fopen()</code> 相关函数返回）。</li>
<li><strong>$length</strong>（可选）：指定读取的最大字节数。如果省略，则默认读取一行直到遇到换行符或文件结尾。</li>
</ol>
<h3 id="行为"><a href="#行为" class="headerlink" title="行为"></a><strong>行为</strong></h3><ul>
<li><code>fgets()</code> 会读取并返回文件中的 <strong>一行文本</strong>，包含换行符（<code>\n</code>）。</li>
<li>如果到达文件末尾，<code>fgets()</code> 会返回 <strong><code>false</code></strong>。</li>
<li>如果指定了 <code>$length</code>，则最多读取 <code>$length</code> 个字节（包括换行符）。</li>
</ul>
<h3 id="示例-1：逐行读取文件"><a href="#示例-1：逐行读取文件" class="headerlink" title="示例 1：逐行读取文件"></a><strong>示例 1：逐行读取文件</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$file = fopen(&#x27;file.txt&#x27;, &#x27;r&#x27;);</span><br><span class="line">while (($line = fgets($file)) !== false) &#123;</span><br><span class="line">    echo $line . &quot;&lt;br&gt;&quot;;  // 输出每一行的内容</span><br><span class="line">&#125;</span><br><span class="line">fclose($file);</span><br></pre></td></tr></table></figure>

<h3 id="示例-2：指定最大读取字节数"><a href="#示例-2：指定最大读取字节数" class="headerlink" title="示例 2：指定最大读取字节数"></a><strong>示例 2：指定最大读取字节数</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$file = fopen(&#x27;file.txt&#x27;, &#x27;r&#x27;);</span><br><span class="line">$line = fgets($file, 100);  // 读取最多 100 个字符</span><br><span class="line">echo $line;</span><br><span class="line">fclose($file);</span><br></pre></td></tr></table></figure>

<h3 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a><strong>返回值</strong></h3><ul>
<li><strong>成功时</strong>：返回读取到的一行内容（字符串）。</li>
<li><strong>失败时</strong>：返回 <strong><code>false</code></strong>，通常表示文件结尾（EOF）或出现错误。</li>
</ul>
<h3 id="与-fread-的区别"><a href="#与-fread-的区别" class="headerlink" title="与 fread() 的区别"></a><strong>与 <code>fread()</code> 的区别</strong></h3><ul>
<li><code>fgets()</code> 每次读取一行（以换行符为结束标志）。</li>
<li><code>fread()</code> 读取固定长度的字节，无论是否是行的结束。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p><code>fgets()</code> 是一个用于读取文件中一行文本的常用函数，特别适用于需要逐行处理文件内容的场景，常与 <code>fopen()</code> 一起使用。它的关键优势是 <strong>逐行读取</strong>，不会一次性将整个文件加载到内存中，适用于读取较大的文件。</p>
<h3 id="fread"><a href="#fread" class="headerlink" title="fread"></a>fread</h3><p><code>fread()</code> 是 PHP 中的一个文件操作函数，用于 <strong>从文件指针中读取指定字节数的内容</strong>。它不是逐行读取，而是根据传入的长度读取文件的部分内容。</p>
<h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a><strong>用法</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">file = fopen(&#x27;path/to/file.txt&#x27;, &#x27;r&#x27;);  // 打开文件以只读模式</span><br><span class="line">$contents = fread($file, 100);  // 读取最多 100 字节内容</span><br><span class="line">echo $contents;</span><br><span class="line">fclose($file);</span><br></pre></td></tr></table></figure>

<h4 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a><strong>参数</strong></h4><ul>
<li><strong>$file</strong>：有效的文件指针（通过 <code>fopen()</code> 获取）。</li>
<li><strong>$length</strong>：要读取的字节数。<code>fread()</code> 会最多读取 <code>$length</code> 个字节。</li>
</ul>
<h4 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a><strong>返回值</strong></h4><ul>
<li>如果成功，返回读取的内容（字符串）。</li>
<li>如果失败，返回 <strong><code>false</code></strong>，通常在遇到文件末尾或其他错误时发生。</li>
</ul>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h4><ul>
<li><strong><code>fread()</code></strong> 不会按行读取，它是按字节读取的，可以用来读取文件的一部分（不一定是以换行符为界）。</li>
<li>如果读取的字节数超过文件的剩余部分，<code>fread()</code> 会读取整个文件直到 EOF。</li>
</ul>
<h4 id="示例-1：读取指定字节数"><a href="#示例-1：读取指定字节数" class="headerlink" title="示例 1：读取指定字节数"></a><strong>示例 1：读取指定字节数</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$file = fopen(&#x27;file.txt&#x27;, &#x27;r&#x27;);</span><br><span class="line">$content = fread($file, 50);  // 读取前 50 个字节</span><br><span class="line">echo $content;</span><br><span class="line">fclose($file);</span><br></pre></td></tr></table></figure>

<h4 id="示例-2：读取整个文件内容"><a href="#示例-2：读取整个文件内容" class="headerlink" title="示例 2：读取整个文件内容"></a><strong>示例 2：读取整个文件内容</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$file = fopen(&#x27;file.txt&#x27;, &#x27;r&#x27;);</span><br><span class="line">$content = fread($file, filesize(&#x27;file.txt&#x27;));  // 读取整个文件</span><br><span class="line">echo $content;</span><br><span class="line">fclose($file);</span><br></pre></td></tr></table></figure>



<h3 id="current"><a href="#current" class="headerlink" title="current"></a>current</h3><p><code>current()</code> 是 PHP 中的一个数组函数，用于 <strong>返回数组中当前元素的值</strong>。它并不直接与文件操作相关，但在处理可迭代对象（如 <code>SplFileObject</code>）时常常被使用。</p>
<h4 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a><strong>用法</strong></h4><p><code>current()</code> 用于访问数组中的当前元素或 <code>SplFileObject</code>（一个类数组对象）的当前行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">php复制编辑$array = [&#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;cherry&#x27;];</span><br><span class="line">echo current($array);  // 输出 &#x27;apple&#x27;</span><br></pre></td></tr></table></figure>

<h4 id="与-SplFileObject-配合使用"><a href="#与-SplFileObject-配合使用" class="headerlink" title="与 SplFileObject 配合使用"></a><strong>与 <code>SplFileObject</code> 配合使用</strong></h4><p>当你用 <code>SplFileObject</code> 逐行读取文件时，<code>current()</code> 可以用来获取文件中的当前行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">php复制编辑$file = new SplFileObject(&#x27;file.txt&#x27;);</span><br><span class="line">echo $file-&gt;current();  // 获取当前行内容</span><br></pre></td></tr></table></figure>

<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a><strong>特点</strong></h4><ul>
<li><code>current()</code> 不需要传递参数，它会根据 <strong>当前的内部指针</strong> 返回当前元素。</li>
<li>如果你使用 <code>SplFileObject</code>，则 <code>current()</code> 返回的是文件的当前行内容（每次调用后文件指针会向下移动）。</li>
</ul>
<h4 id="与-fgets-的关系"><a href="#与-fgets-的关系" class="headerlink" title="与 fgets() 的关系"></a><strong>与 <code>fgets()</code> 的关系</strong></h4><ul>
<li><code>fgets()</code> 是 <strong>逐行读取文件</strong>，而 <code>current()</code> 是获取 <strong>当前行内容</strong>（在迭代器中）。</li>
<li>使用 <code>SplFileObject</code> 时，你可以用 <code>current()</code> 来获取当前行，<code>next()</code> 来跳到下一行。</li>
</ul>
<p><strong><code>fread()</code></strong> 适合在读取文件的任意部分时使用（按字节读取）。</p>
<p><strong><code>current()</code></strong> 适合在使用数组或迭代器（如 <code>SplFileObject</code>）时读取当前元素（如当前行）。</p>
<h3 id="php传参绕过点符号的问题"><a href="#php传参绕过点符号的问题" class="headerlink" title="php传参绕过点符号的问题"></a>php传参绕过点符号的问题</h3><p>在 PHP 中，<code>$_GET[&#39;e_m.p&#39;]</code> 实际上是一个键名。由于点 (<code>.</code>) 符号通常在 PHP 中被用作数组的层级分隔符，因此直接使用 <code>e_m.p</code> 会在某些情况下引发问题或受到过滤。然而，<strong><code>[ ]</code></strong> 是数组的符号，可以用来绕过这个问题。</p>
<h4 id="如何绕过："><a href="#如何绕过：" class="headerlink" title="如何绕过："></a><strong>如何绕过：</strong></h4><ul>
<li>当你直接传递 <code>e_m.p</code> 时，PHP 会把它当作 <strong>数组键</strong> 来解析。</li>
<li>如果你使用 <strong><code>e[m.p</code></strong> 作为键，PHP 会 <strong>正确地解析它为一个数组键 <code>e[m.p</code></strong>，而不需要担心点 (<code>.</code>) 会作为数组的层级分隔符。</li>
</ul>
<p>例如，传递 <code>e[m.p</code> 会变成一个单独的键名，这样就绕过了点符号的潜在问题。</p>
<h4 id="更详细的解释："><a href="#更详细的解释：" class="headerlink" title="更详细的解释："></a><strong>更详细的解释：</strong></h4><ul>
<li><p>PHP 中，<code>$_GET</code> 数组中的键可以是任意字符串，默认情况下，点（<code>.</code>）用作多维数组的分隔符。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$_GET[&#x27;foo.bar&#x27;]  // 会被解析为 $_GET[&#x27;foo&#x27;][&#x27;bar&#x27;]</span><br></pre></td></tr></table></figure>

<p>但是，如果你使用 <strong><code>[ ]</code></strong> 来包裹点符号，它会被当作一个普通的字符来处理，而不是层级分隔符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$_GET[&#x27;e[m.p&#x27;]  // 这里 `e[m.p` 被当作一个整体的字符串键</span><br></pre></td></tr></table></figure>
</li>
<li><p>这样，<code>e[m.p</code> 就不会被分解成多个层级，而是一个单一的字符串。它被视为一个合法的查询参数，可以顺利通过 PHP 的解析。</p>
</li>
</ul>
<h4 id="举个例子："><a href="#举个例子：" class="headerlink" title="举个例子："></a><strong>举个例子：</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 如果你使用以下 URL：</span><br><span class="line">http://example.com/index.php?e[m.p]=114514</span><br><span class="line"></span><br><span class="line">// 在 PHP 中，你会得到：</span><br><span class="line">$_GET[&#x27;e[m.p&#x27;] = &#x27;114514&#x27;;</span><br><span class="line"></span><br><span class="line">// 而如果使用点符号：</span><br><span class="line">http://example.com/index.php?e_m.p=114514</span><br><span class="line"></span><br><span class="line">// PHP 可能会处理成一个层级结构（例如，数组解析错误等）。</span><br></pre></td></tr></table></figure>

<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结：</strong></h4><p>你需要传递 <code>e[m.p</code> 而不是 <code>e_m.p</code>，是为了绕过 PHP 默认的 <strong>点符号</strong> 解析规则。使用 <strong><code>[ ]</code></strong> 来包裹点符号，可以避免 PHP 将其当作数组层级分隔符解析，从而保证你能够正确地传递这个参数。</p>
<h4 id="有一道题-为什么被转换成立"><a href="#有一道题-为什么被转换成立" class="headerlink" title="有一道题  [ 为什么被转换成立_"></a>有一道题  [ 为什么被转换成立_</h4><p>在 PHP 中，<code>$_GET</code> 数组中的键名可能会经历一些特殊的处理和转换，特别是在 HTTP 请求过程中。如果你传递的 URL 包含某些特殊字符（如 <code>[</code>, <code>]</code>, <code>.</code> 等），PHP 会尝试根据其规则进行解析和标准化，通常会进行 URL 解码或替换不被允许的字符。</p>
<h3 id="关键原因：URL-编码和字符替换"><a href="#关键原因：URL-编码和字符替换" class="headerlink" title="关键原因：URL 编码和字符替换"></a>关键原因：URL 编码和字符替换</h3><ol>
<li><strong>URL 编码和解码：</strong><ul>
<li>在 HTTP 请求的 URL 中，特殊字符（如 <code>[</code> 和 <code>]</code>）是 <strong>URL 编码</strong> 的。例如，<code>[</code> 会被编码为 <code>%5B</code>，<code>]</code> 会被编码为 <code>%5D</code>。</li>
<li>如果你在 URL 中传递 <code>e[m.p</code>，它可能会被浏览器或 PHP 自动编码成 <code>e%5Bm.p</code>。然后，PHP 在接收到请求时，会自动对这些编码字符进行 <strong>URL 解码</strong>。</li>
</ul>
</li>
<li><strong>PHP 的自动解析和处理：</strong><ul>
<li>PHP 在解析查询字符串时会自动进行一些字符替换，特别是当它遇到某些符号时。例如，<code>[</code> 和 <code>]</code> 通常会被替换或忽略，导致它们在 <code>$_GET</code> 中被转换为下划线（<code>_</code>）或其他符号。</li>
<li>这是 PHP 的一种 <strong>容错机制</strong>，旨在确保不会出现不合法的数组键。具体地，在某些配置下，PHP 会自动将 <code>[</code> 和 <code>]</code> 转换为 <code>_</code>，以确保不会引发解析错误或混乱。</li>
</ul>
</li>
</ol>
<h3 id="为什么-和-被替换为-："><a href="#为什么-和-被替换为-：" class="headerlink" title="为什么 [ 和 ] 被替换为 _："></a><strong>为什么 <code>[</code> 和 <code>]</code> 被替换为 <code>_</code>：</strong></h3><p>在某些 PHP 配置或框架中，存在对 URL 中特殊字符的处理机制。以下是可能的原因：</p>
<ul>
<li><strong>PHP 变量命名规范：</strong> PHP 对一些字符（如 <code>[</code> 和 <code>]</code>）有解析限制，认为它们不是合法的变量或数组键的一部分。因此，PHP 会自动将这些符号转换为下划线 <code>_</code> 来确保变量名的合法性。</li>
<li><strong>框架或安全过滤：</strong> 如果你在使用某些框架或在 PHP 配置中启用了某些安全选项，它们可能会强制将某些字符（如 <code>[</code>, <code>]</code>）转义或替换成下划线 <code>_</code>，以防止潜在的注入攻击或解析问题。</li>
<li><strong>URL 参数处理：</strong> 一些服务器和浏览器可能会对 <code>[</code> 和 <code>]</code> 做特殊的处理。它们会自动将这些字符进行转换，以避免 PHP 在处理数组参数时出错。</li>
</ul>
<h3 id="如何验证这一点："><a href="#如何验证这一点：" class="headerlink" title="如何验证这一点："></a><strong>如何验证这一点：</strong></h3><p>你可以尝试以下的实验，看看 PHP 如何处理 URL 中的特殊字符：</p>
<ol>
<li><p>传递参数时，编码特殊字符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/index.php?e%5Bm.p%5D=114514</span><br></pre></td></tr></table></figure>
</li>
<li><p>PHP 解析时：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var_dump($_GET);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>你可能会看到 PHP 会自动对 <code>[ ]</code> 进行转换，可能变成了 <code>_</code> 或其他字符。</p>
<h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a><strong>总结：</strong></h3><ul>
<li>PHP 会对 URL 中的特殊字符（如 <code>[</code>, <code>]</code>）进行 <strong>URL 解码</strong>，并可能会自动 <strong>替换或转义</strong> 这些字符为下划线 <code>_</code>，以避免解析问题。</li>
<li>这种替换行为可能是由 <strong>PHP 的解析规则</strong>、<strong>URL 编码解码机制</strong> 或 <strong>框架的特殊处理</strong> 引起的。</li>
</ul>
<p>因此，<code>[ ]</code> 被转换为 <code>_</code>，通常是 PHP 在处理请求时为避免解析错误或不合法字符所做的自动调整。</p>
<h3 id="在linux下面表示当前目录是"><a href="#在linux下面表示当前目录是" class="headerlink" title="在linux下面表示当前目录是   .&#x2F;"></a><strong>在linux下面表示当前目录是   .&#x2F;</strong></h3><p><img src="C:\Users\csdd\AppData\Roaming\Typora\typora-user-images\image-20250318195110595.png" alt="image-20250318195110595"></p>
<p>当前目录访问   .&#x2F;flag.php</p>
<h3 id="md5绕过"><a href="#md5绕过" class="headerlink" title="md5绕过"></a>md5绕过</h3><p><a href="https://blog.csdn.net/2301_80307383/article/details/140827718">https://blog.csdn.net/2301_80307383/article/details/140827718</a></p>
<p>强类型</p>
<p>数组绕过md5($a)&#x3D;&#x3D;&#x3D;md5($b)且$a!&#x3D;&#x3D;$b</p>
<p>原理：md5对数组加密结果为NULL</p>
<p>传入a[]&#x3D;1&amp;b[]&#x3D;2即可绕过，数组绕过也可用于弱类型</p>
<h3 id="is-numeric-函数"><a href="#is-numeric-函数" class="headerlink" title="is_numeric() 函数"></a><code>is_numeric()</code> 函数</h3><p><code>is_numeric()</code> 是 PHP 内置的一个函数，用于检查变量是否为 <strong>数字或数字字符串</strong>。</p>
<h3 id="substr-函数"><a href="#substr-函数" class="headerlink" title="substr() 函数"></a><code>substr()</code> 函数</h3><p><code>substr()</code> 是 PHP 内置函数，用于<strong>截取字符串的一部分</strong>。</p>
<h3 id="array-push-函数"><a href="#array-push-函数" class="headerlink" title="array_push() 函数"></a><code>array_push()</code> 函数</h3><h2 id="🔹-语法"><a href="#🔹-语法" class="headerlink" title="🔹 语法"></a><strong>🔹 语法</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array_push(array &amp;$array, mixed ...$values): int</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>$array</code></strong>：目标数组（会被修改）</li>
<li><strong><code>$values</code></strong>：要添加的值（可以是多个）</li>
<li><strong>返回值</strong>：返回<strong>新数组的长度</strong></li>
</ul>
<p><strong><code>array_push()</code> 返回新数组长度</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$colors = [&quot;Red&quot;, &quot;Blue&quot;];</span><br><span class="line">$new_length = array_push($colors, &quot;Green&quot;, &quot;Yellow&quot;);</span><br><span class="line">echo $new_length; // 输出 4</span><br></pre></td></tr></table></figure>

<h2 id="🛠-用途"><a href="#🛠-用途" class="headerlink" title="🛠 用途"></a><strong>🛠 用途</strong></h2><p>🔹 <strong>动态数组扩展</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$stack = [];</span><br><span class="line">array_push($stack, &quot;First&quot;);</span><br><span class="line">array_push($stack, &quot;Second&quot;);</span><br><span class="line">print_r($stack);</span><br></pre></td></tr></table></figure>

<p>🔹 <strong>模拟栈（LIFO - 后进先出）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$stack = [];</span><br><span class="line">array_push($stack, &quot;A&quot;);</span><br><span class="line">array_push($stack, &quot;B&quot;);</span><br><span class="line">$last = array_pop($stack);  // 取出 &quot;B&quot;</span><br></pre></td></tr></table></figure>

<p>🔹 <strong>合并多个值</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$list = [];</span><br><span class="line">array_push($list, ...[&quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;]);</span><br><span class="line">print_r($list);</span><br></pre></td></tr></table></figure>

<h3 id="rand"><a href="#rand" class="headerlink" title="rand"></a>rand</h3><p><code>rand(1, $i)</code> 生成一个<strong>介于 <code>1</code> 和 <code>$i</code> 之间的随机数</strong></p>
<h3 id="in-array-GET-n-allow-作用"><a href="#in-array-GET-n-allow-作用" class="headerlink" title="in_array($_GET[&#39;n&#39;], $allow) 作用"></a><code>in_array($_GET[&#39;n&#39;], $allow)</code> 作用</h3><p><code>in_array($_GET[&#39;n&#39;], $allow)</code> 用于<strong>检查 <code>$_GET[&#39;n&#39;]</code> 是否存在于 <code>$allow</code> 数组中</strong>。</p>
<h3 id="in-array-详解"><a href="#in-array-详解" class="headerlink" title="in_array() 详解"></a><strong><code>in_array()</code> 详解</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in_array(mixed $needle, array $haystack, bool $strict = false): bool</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>$needle</code></strong>：要搜索的值（这里是 <code>$_GET[&#39;n&#39;]</code>）。</li>
<li><strong><code>$haystack</code></strong>：目标数组（这里是 <code>$allow</code>）。</li>
<li><strong><code>$strict</code></strong>（可选）：默认 <code>false</code>，如果设为 <code>true</code>，会进行<strong>类型严格比较</strong>（<code>===</code>）。</li>
</ul>
<h3 id="ReflectionClass-的作用"><a href="#ReflectionClass-的作用" class="headerlink" title="ReflectionClass 的作用"></a><code>ReflectionClass</code> 的作用</h3><p><code>ReflectionClass</code> 是 PHP 的一个类，用来获取一个类的结构、方法、属性等信息。在这个场景下，<code>new ReflectionClass(&#39;ctfshow&#39;)</code> 会返回一个 <code>ReflectionClass</code> 对象，它包含了关于 <code>ctfshow</code> 类的反射信息。这个类可能包含 flag（如之前提到的注释所示）。</p>
<p>在某些情况下，<code>ReflectionClass</code> 可能会允许访问私有属性、方法，甚至是类中的 flag。</p>
<p>例如</p>
<p>eval(“echo new ReflectionClass(‘ctfshow’);”)</p>
<p>就会创建一个新的 <code>ReflectionClass</code> 对象，<code>ReflectionClass</code> 是 PHP 中用于反射类的一个类。</p>
<p>也就是将ctfshow类里的内容反射到ReflectionClass中</p>
<p>再通过echo输出</p>
<h3 id="hex2bin（）-函数"><a href="#hex2bin（）-函数" class="headerlink" title="hex2bin（） 函数"></a><code>hex2bin（）</code> 函数</h3><p>hex2bin可以将传入的十六进制数据解码为原始数据</p>
<p>可以传一下只能用数字传入的木马</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?=</span> ... <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="：这是-PHP-的短标签语法，用于输出表达式的结果。-相当于"><a href="#：这是-PHP-的短标签语法，用于输出表达式的结果。-相当于" class="headerlink" title="：这是 PHP 的短标签语法，用于输出表达式的结果。 相当于&lt;?php echo””"></a>：这是 PHP 的短标签语法，用于输出表达式的结果。 相当于&lt;?php echo””</h3><ul>
<li><pre><code class="language-php">`cat *`
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  ：这是 PHP 中的反引号操作符，用于执行其中的命令作为 shell 命令。在这里，它会在 shell 中运行 `cat *`。</span><br><span class="line"></span><br><span class="line">- ```php</span><br><span class="line">  `cat *`</span><br></pre></td></tr></table></figure>

：这是一个 shell 命令，会读取并输出当前目录下所有文件（`*`）的内容。
</code></pre>
</li>
</ul>
<h3 id="PHP-中关于哈希函数的返回结果"><a href="#PHP-中关于哈希函数的返回结果" class="headerlink" title="PHP 中关于哈希函数的返回结果"></a>PHP 中关于哈希函数的返回结果</h3><p>不论是 md5 还是 sha1 函数，当其参数为一个数组时，函数不能将其转换为对应的哈希值，因此返回值为空（即 null），但并不是 false，而是 warning</p>
<p>false 的程序讨论其返回值是没有意义的，但 warning 的程序返回值会根据实际情况而有所不同</p>
<p>因此，当哈希函数的参数为数组时，其返回的值为 null 而不是 false</p>
<p>另一种解释sh1  两个数组的话指针在比较时不相等，但作为sha1的参数时，会调用方法变成字符串Array，故sha1相等</p>
<p>sh1碰撞  aaK1STfY  aaO8zKZF</p>
<h3 id="parse-str-v1-v2"><a href="#parse-str-v1-v2" class="headerlink" title="parse_str($v1,$v2);"></a>parse_str($v1,$v2);</h3><p><code>parse_str($b);</code> 的作用是解析 <code>b=key=value</code> 形式的字符串，并将变量 <code>key</code> 赋值为 <code>value</code>。</p>
<p><img src="/../picture/image-20250330100022834.png" alt="image-20250330100022834"></p>
<p>比如这个要给a[0]赋值  但是不能直接传参   就可以通过parse_str函数  传参b&#x3D;a[ ]&#x3D;“xxx” 将 a[]赋值为xxx</p>
<p><code>parse_str()</code> 是一个 PHP 内置函数，它的作用是将查询字符串解析为 PHP 变量</p>
<p>这行代码的作用是：</p>
<ul>
<li>解析字符串 <code>$v1</code>，并将解析结果存入数组 <code>$v2</code>。</li>
</ul>
<p><strong>示例 1：基本解析</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$v1 = &quot;name=Darkxell&amp;age=25&quot;;</span><br><span class="line">parse_str($v1, $v2);</span><br><span class="line"></span><br><span class="line">print_r($v2);</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Array</span><br><span class="line">(</span><br><span class="line">    [name] =&gt; Darkxell</span><br><span class="line">    [age] =&gt; 25</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>✅ <code>$v2</code> 成功存储了解析后的键值对。</p>
<hr>
<p><strong>示例 2：解析数组格式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$v1 = &quot;user[name]=Darkxell&amp;user[age]=25&quot;;</span><br><span class="line">parse_str($v1, $v2);</span><br><span class="line"></span><br><span class="line">print_r($v2);</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Array</span><br><span class="line">(</span><br><span class="line">    [user] =&gt; Array</span><br><span class="line">        (</span><br><span class="line">            [name] =&gt; Darkxell</span><br><span class="line">            [age] =&gt; 25</span><br><span class="line">        )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>✅ <code>parse_str()</code> 能解析数组格式的查询字符串，将 <code>user[name]</code> 和 <code>user[age]</code> 解析成嵌套数组。</p>
<hr>
<p><strong>示例 3：处理特殊字符</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$v1 = &quot;message=Hello%20World%21&quot;;</span><br><span class="line">parse_str($v1, $v2);</span><br><span class="line"></span><br><span class="line">print_r($v2);</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Array</span><br><span class="line">(</span><br><span class="line">    [message] =&gt; Hello World!</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>✅ <code>parse_str()</code> 自动解码 URL 编码的字符，如 <code>%20</code> → 空格，<code>%21</code> → <code>!</code>。</p>
<p><img src="/../picture/image-20250319213743317.png" alt="image-20250319213743317"></p>
<p>本题中**<code>$v2[&#39;flag&#39;]</code> 代表 <code>$v2</code> 数组中 <code>flag</code> 这个键对应的值**。</p>
<p>也就是我们传入的v1  要给它一个flag键</p>
<p>然后parse_str函数会将flag的键值存储到$v2里然后与md5($v3)比较</p>
<p>还可以v3[]&#x3D;1  数组绕过 让其为NULL   v1随便传</p>
<p>也可以v3&#x3D;240610708  md5编码后为0e462097431906509019562988736854</p>
<p>v1&#x3D;0   进行0e绕过</p>
<h3 id="strrev-函数"><a href="#strrev-函数" class="headerlink" title="strrev()函数"></a>strrev()函数</h3><p><code>strrev()</code> 是 PHP 的一个内建函数，用于 <strong>反转字符串</strong>。</p>
<h4 id="语法："><a href="#语法：" class="headerlink" title="语法："></a><strong>语法：</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string strrev(string $string)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>$string</code></strong>：要反转的字符串。</li>
</ul>
<h4 id="返回值："><a href="#返回值：" class="headerlink" title="返回值："></a><strong>返回值：</strong></h4><ul>
<li>返回一个反转后的字符串。</li>
</ul>
<h3 id="ereg函数"><a href="#ereg函数" class="headerlink" title="ereg函数"></a>ereg函数</h3><p>功能基本和preg_match()函数一样</p>
<p>ereg现在在高版本php环境已废弃</p>
<p>它存在NULL截断漏洞，可以导致正则过滤被绕过,必要时可以使用%00截断正则匹配</p>
<p>例如a%00778 他就只会检查a  而不会检查%00后面的778    </p>
<h3 id="Exception-异常处理类"><a href="#Exception-异常处理类" class="headerlink" title="Exception 异常处理类"></a><code>Exception</code> 异常处理类</h3><p>在 PHP 中，<code>Exception</code> 是 <strong>所有异常的基类</strong>。当代码运行时发生错误，我们可以 <strong>抛出</strong>（throw）一个 <code>Exception</code>，然后在 <code>catch</code> 语句中捕获它，执行错误处理逻辑。</p>
<p>执行方法和Reflectionclass类似  但二者意义不同</p>
<p><code>Exception</code> 本质上是一个普通的类，它包含了异常的信息，如错误消息、错误代码、发生的文件和行号等。</p>
<p>也就是Exception主要返回错误信息   </p>
<p>Reflectionclass是动态调用一个方法</p>
<p>用途不同</p>
<table>
<thead>
<tr>
<th>类</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>Exception</code></td>
<td><strong>异常处理</strong>（用于错误捕获）</td>
</tr>
<tr>
<td><code>ReflectionClass</code></td>
<td><strong>反射 API</strong>（用于动态分析和操作类）</td>
</tr>
</tbody></table>
<p><code>ReflectionFunction</code> 也可以用于信息泄露</p>
<p><code>DOMDocument</code> 也可以用于文件读取攻击</p>
<h3 id="getcwd-用法"><a href="#getcwd-用法" class="headerlink" title="getcwd() 用法"></a><strong><code>getcwd()</code> 用法</strong></h3><p><code>getcwd()</code> 是 PHP 内置函数，返回当前工作目录（Current Working Directory, CWD）。</p>
<h3 id="GLOBALS-数组"><a href="#GLOBALS-数组" class="headerlink" title="GLOBALS 数组"></a><code>GLOBALS</code> 数组</h3><p>在 PHP 中，<code>GLOBALS</code> 是一个特殊的超级全局数组，它包含了所有全局作用域中的变量。通过这个数组，你可以访问或修改任何全局变量，即使是在函数或方法内，也能跨作用域访问全局变量。</p>
<h3 id="GLOBALS-数组-1"><a href="#GLOBALS-数组-1" class="headerlink" title="GLOBALS 数组"></a><strong><code>GLOBALS</code> 数组</strong></h3><p><code>GLOBALS</code> 数组是 PHP 内置的，所有全局变量都可以通过这个数组进行访问。其键是全局变量的名称，值是变量的值。</p>
<h4 id="访问全局变量"><a href="#访问全局变量" class="headerlink" title="访问全局变量"></a><strong>访问全局变量</strong></h4><p>假设有一个全局变量 <code>$foo</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$foo = &quot;Hello, World!&quot;;</span><br></pre></td></tr></table></figure>

<p>在函数中，你可以通过 <code>GLOBALS</code> 数组访问它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function test() &#123;</span><br><span class="line">    echo $GLOBALS[&#x27;foo&#x27;]; // 输出 Hello, World!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure>

<p>也就是利用GLOBALS访问全局变量   因为不知道flag变量   访问它flag可能在其中   </p>
<h3 id="is-file-函数"><a href="#is-file-函数" class="headerlink" title="is_file()函数"></a>is_file()函数</h3><p><code>is_file()的</code> 的长度限制依赖于操作系统的最大路径长度限制。</p>
<p>在大多数操作系统中，路径的最大长度为 4096 字节（Linux 和 macOS）或 260 字符（Windows，除非启用长路径支持）。</p>
<p>如果路径超出了操作系统允许的最大长度，操作系统会返回错误，导致 <code>is_file()</code> 返回 <code>false</code>。</p>
<h4 id="语法：-1"><a href="#语法：-1" class="headerlink" title="语法："></a><strong>语法：</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">is_file(string $filename): bool</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>参数</strong>：<code>$filename</code> 是文件路径的字符串，可以是相对路径或绝对路径。</p>
</li>
<li><p>返回值</p>
<p>：</p>
<ul>
<li><strong><code>true</code></strong>：如果指定的路径指向一个存在的常规文件（而不是目录、符号链接或其他类型的文件）。</li>
<li><strong><code>false</code></strong>：如果指定的路径不存在、是目录或其他类型的文件。</li>
</ul>
</li>
</ul>
<h4 id="功能："><a href="#功能：" class="headerlink" title="功能："></a><strong>功能</strong>：</h4><p><code>is_file()</code> 用于检查指定路径是否是一个<strong>常规文件</strong>。它不检查目录、符号链接等。如果指定路径存在并且是一个文件（不是目录），则返回 <code>true</code>；如果路径不存在或是一个目录，则返回 <code>false</code>。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a><strong>例子</strong></h3><ol>
<li><strong>检查文件是否存在并且是一个常规文件：</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$file = &#x27;path/to/your/file.txt&#x27;;</span><br><span class="line"></span><br><span class="line">if (is_file($file)) &#123;</span><br><span class="line">    echo &quot;The file exists and is a regular file.&quot;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    echo &quot;The file does not exist or is not a regular file.&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong>检查文件是否是目录：</strong> 如果你想检查文件是否是目录，可以使用 <code>is_dir()</code> 函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$dir = &#x27;path/to/your/directory&#x27;;</span><br><span class="line"></span><br><span class="line">if (is_dir($dir)) &#123;</span><br><span class="line">    echo &quot;This is a directory.&quot;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    echo &quot;This is not a directory.&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>示例：检查文件是否存在并读取内容：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$file = &#x27;example.txt&#x27;;</span><br><span class="line"></span><br><span class="line">if (is_file($file)) &#123;</span><br><span class="line">    $content = file_get_contents($file);  // 读取文件内容</span><br><span class="line">    echo $content;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    echo &quot;The file does not exist.&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="常见用途"><a href="#常见用途" class="headerlink" title="常见用途"></a><strong>常见用途</strong></h3><ul>
<li><strong>验证文件是否存在并且可以操作</strong>：确保路径指向的是一个有效的文件，而不是目录或不存在的路径。</li>
<li><strong>读取文件前验证</strong>：在读取文件前使用 <code>is_file()</code> 来避免错误。</li>
<li><strong>文件上传检查</strong>：上传文件时，可以用 <code>is_file()</code> 检查文件路径，确保上传的是文件。</li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h3><ul>
<li><p><code>is_file()</code> 不会检查文件是否具有读取权限。如果你需要检查文件的读取权限，可以结合使用 <code>is_readable()</code> 函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (is_file($file) &amp;&amp; is_readable($file)) &#123;</span><br><span class="line">    echo &quot;The file exists and is readable.&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>is_file()</code> 只能检查普通文件，无法检测符号链接或目录，若需要分别处理目录、符号链接等，可以使用 <code>is_dir()</code> 和 <code>is_link()</code> 等函数。</p>
</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong>总结</strong></h3><p><code>is_file()</code> 是一个用于检查路径是否是常规文件的有用函数，在处理文件时常常用来确保操作的是有效的文件，而不是目录或其他文件类型。</p>
<p><strong>php文件读取新方法</strong></p>
<h3 id="php-filter-convert-iconv-UCS-2LE-UCS-2BE-resource-flag-php"><a href="#php-filter-convert-iconv-UCS-2LE-UCS-2BE-resource-flag-php" class="headerlink" title="php://filter/convert.iconv.UCS-2LE.UCS-2BE/resource=flag.php"></a><strong><code>php://filter/convert.iconv.UCS-2LE.UCS-2BE/resource=flag.php</code></strong></h3><p>这个流包装器将对文件内容进行 <strong>字符编码转换</strong>。</p>
<ul>
<li><strong><code>convert.iconv.UCS-2LE.UCS-2BE</code></strong>：<ul>
<li>将文件内容从 <strong>UCS-2 Little Endian (LE)</strong> 编码转换为 <strong>UCS-2 Big Endian (BE)</strong> 编码。</li>
<li>文件 <code>flag.php</code> 将在读取时应用这种编码转换。</li>
</ul>
</li>
<li><strong>用法</strong>：这种转换可以在读取文件时进行字符编码转换。</li>
</ul>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$file = file_get_contents(&#x27;php://filter/convert.iconv.UCS-2LE.UCS-2BE/resource=flag.php&#x27;);</span><br></pre></td></tr></table></figure>

<p>这将读取 <code>flag.php</code> 文件，并在读取时将其内容从 UCS-2 Little Endian 编码转换为 UCS-2 Big Endian 编码。</p>
<h3 id="php-filter-read-convert-quoted-printable-encode-resource-flag-php"><a href="#php-filter-read-convert-quoted-printable-encode-resource-flag-php" class="headerlink" title="php://filter/read=convert.quoted-printable-encode/resource=flag.php"></a><strong><code>php://filter/read=convert.quoted-printable-encode/resource=flag.php</code></strong></h3><p>这个流包装器将文件内容 <strong>以 quoted-printable 编码进行转换</strong>。</p>
<ul>
<li><strong><code>convert.quoted-printable-encode</code></strong>：<ul>
<li>将文件内容转换为 <strong>quoted-printable 编码</strong>，这种编码通常用于电子邮件中传输非 ASCII 字符或二进制数据。</li>
</ul>
</li>
<li><strong>用法</strong>：这种转换通常用于编码文件内容，以便将其传输到电子邮件或需要编码的其他系统。</li>
</ul>
<h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file = file_get_contents(&#x27;php://filter/read=convert.quoted-printable-encode/resource=flag.php&#x27;);</span><br></pre></td></tr></table></figure>

<p>这将读取 <code>flag.php</code> 文件，并对其内容应用 quoted-printable 编码。</p>
<h3 id="compress-zlib-flag-php"><a href="#compress-zlib-flag-php" class="headerlink" title="compress.zlib://flag.php"></a><strong><code>compress.zlib://flag.php</code></strong></h3><p>这个流包装器允许你读取 <code>flag.php</code> 文件 <strong>并应用 zlib 压缩</strong>。</p>
<ul>
<li><p><code>compress.zlib://</code></p>
<p>：</p>
<ul>
<li>这个包装器用于读取经过 <strong>zlib 压缩</strong>的文件，并且会在读取时自动解压缩文件内容。</li>
<li>它可以在读取压缩文件时避免手动解压。</li>
</ul>
</li>
</ul>
<h4 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$file = file_get_contents(&#x27;compress.zlib://flag.php&#x27;);</span><br></pre></td></tr></table></figure>

<p>这将读取 <code>flag.php</code> 文件的压缩内容，并使用 zlib 解压缩后返回其原始内容。</p>
<p><strong>常见的过滤器：</strong></p>
<p><strong>convert.quoted-printable-encode</strong></p>
<p><strong>convert.iconv.</strong>*</p>
<p><strong>zlib.deflate</strong>   php:&#x2F;&#x2F;filter&#x2F;zlib.deflate|zlib.inflate&#x2F;resource&#x3D;flag.php</p>
<p><strong>bzip2.compress</strong></p>
<p><strong>string.rot13</strong></p>
<p><strong>string.tolower</strong></p>
<p><strong>convert.base64-decode</strong></p>
<h3 id="在php中-proc-self-root代表根目录"><a href="#在php中-proc-self-root代表根目录" class="headerlink" title="在php中&#x2F;proc&#x2F;self&#x2F;root代表根目录"></a><strong>在php中&#x2F;proc&#x2F;self&#x2F;root代表根目录</strong></h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p><strong><code>%0a</code>：这是 换行符 (LF)（ASCII 值 10）的 URL 编码，通常表示换行符 (<code>\n</code>)。</strong></p>
<p><strong><code>%0b</code>：这是 垂直制表符 (VT)（ASCII 值 11）的 URL 编码，是一个不可打印字符，用于垂直制表。</strong></p>
<p><strong><code>%0d</code>：这是 回车符 (CR)（ASCII 值 13）的 URL 编码，通常用于将光标移动到行的开头 (<code>\r</code>)。</strong></p>
<p><strong><code>%20</code>：这是 空格字符（ASCII 值 32）的 URL 编码，常用于表示单词之间的空格。</strong></p>
<p><strong><code>%09</code>：这是 水平制表符 (HT)（ASCII 值 9）的 URL 编码，通常表示水平制表空格（<code>\t</code>）。</strong></p>
<p><strong><code>%0c</code>：这是 换页符 (FF)（ASCII 值 12）的 URL 编码，是一个不可打印字符，用于分页</strong></p>
<h3 id="SERVER-‘argv’"><a href="#SERVER-‘argv’" class="headerlink" title="$_SERVER[‘argv’]"></a>$_SERVER[‘argv’]</h3><p><code>$_SERVER[&#39;argv&#39;]</code> 是一个包含命令行参数的数组，在 CLI（命令行接口）模式下使用。它存储了通过命令行传递给 PHP 脚本的所有参数。每个命令行参数都会作为数组中的一个元素，索引为整数。</p>
<ul>
<li><strong><code>$_SERVER[&#39;argv&#39;][0]</code></strong> 是脚本的名称或路径（即运行的 PHP 脚本）。</li>
<li><strong><code>$_SERVER[&#39;argv&#39;][1]</code>、<code>$_SERVER[&#39;argv&#39;][2]</code> 等</strong> 是传递给脚本的其他参数。</li>
</ul>
<h3 id="isset-函数"><a href="#isset-函数" class="headerlink" title="isset()函数"></a>isset()函数</h3><p>主要检查一个变量是否存在  </p>
<p><code>isset()</code> 会返回 <code>false</code> 对于 <code>null</code> 和 <strong>未定义的变量</strong>，但它会返回 <code>true</code> 对于 <strong>空字符串</strong> 和 <strong>0</strong> 等。</p>
<h3 id="empty-函数"><a href="#empty-函数" class="headerlink" title="empty() 函数"></a><code>empty()</code> 函数</h3><p><code>empty()</code> 函数用于检查一个变量是否为空。<strong>“空”</strong> 的标准包括：</p>
<ul>
<li>变量没有设置（未定义）。</li>
<li>变量的值为 <code>null</code>。</li>
<li>变量的值为 <code>&quot;&quot;</code>（空字符串）。</li>
<li>变量的值为 <code>0</code> 或 <code>0.0</code>。</li>
<li>变量的值为 <code>false</code>。</li>
<li>变量是空数组。</li>
</ul>
<h3 id="is-null-函数"><a href="#is-null-函数" class="headerlink" title="is_null() 函数"></a><code>is_null()</code> 函数</h3><p><code>is_null()</code> 用于检查变量是否为 <code>null</code>。</p>
<h3 id="与-特性"><a href="#与-特性" class="headerlink" title="[  与.  特性"></a>[  与.  特性</h3><p>php中变量名只有数字字母下划线，被get或者post传入的变量名，如果含有空格、+、[则会被转化为_，所以按理来说我们构造不出CTF_SHOW.COM这个变量(因为含有.)，但php中有个特性就是如果传入[，它被转化为_之后，后面的字符就会被保留下来不会被替换</p>
<h3 id="get-defined-vars"><a href="#get-defined-vars" class="headerlink" title="get_defined_vars()"></a>get_defined_vars()</h3><p><code>get_defined_vars()</code> 是 PHP 内置的一个函数，它返回当前作用域内所有已定义的变量，以<strong>关联数组</strong>的形式返回，键是变量名，值是变量的内容。例如：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$a</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="variable">$b</span> = <span class="number">42</span>;</span><br><span class="line"><span class="variable">$c</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="title function_ invoke__">get_defined_vars</span>());</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">Array</span></span><br><span class="line">(</span><br><span class="line">    [a] =&gt; hello</span><br><span class="line">    [b] =&gt; <span class="number">42</span></span><br><span class="line">    [c] =&gt; <span class="title function_ invoke__">Array</span></span><br><span class="line">        (</span><br><span class="line">            [<span class="number">0</span>] =&gt; <span class="number">1</span></span><br><span class="line">            [<span class="number">1</span>] =&gt; <span class="number">2</span></span><br><span class="line">            [<span class="number">2</span>] =&gt; <span class="number">3</span></span><br><span class="line">        )</span><br><span class="line">    [...其他PHP内部变量]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个数组包含<strong>所有在当前作用域内的变量</strong>，包括用户定义的变量（如 <code>$a, $b, $c</code>），以及一些 PHP 预定义的变量（如 <code>$_GET, $_POST, $_SERVER, $_SESSION</code> 等）。</p>
</blockquote>
<h3 id="var-export"><a href="#var-export" class="headerlink" title="var_export()"></a>var_export()</h3><p><code>var_export()</code> 用于将变量的值以<strong>PHP 代码字符串的形式输出</strong>，类似于 <code>print_r()</code>，但它的输出格式更适合直接用于代码中。例如：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="title function_ invoke__">var_export</span>(<span class="variable">$a</span>);</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">array</span> (</span><br><span class="line">  <span class="number">0</span> =&gt; <span class="number">1</span>,</span><br><span class="line">  <span class="number">1</span> =&gt; <span class="number">2</span>,</span><br><span class="line">  <span class="number">2</span> =&gt; <span class="number">3</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这个输出格式可以直接复制粘贴到 PHP 代码中，并作为数组变量使用。</p>
<h3 id="extract-是什么"><a href="#extract-是什么" class="headerlink" title="extract() 是什么"></a><code>extract()</code> 是什么</h3><h4 id="1-extract-是什么？"><a href="#1-extract-是什么？" class="headerlink" title="1. extract() 是什么？"></a><strong>1. <code>extract()</code> 是什么？</strong></h4><p><code>extract()</code> 是 PHP 的一个内置函数，它用于<strong>从数组中提取键值对，并将键作为变量名，值作为变量值赋值到当前作用域</strong>。</p>
<p><strong>语法：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extract(array $array, int $flags = EXTR_OVERWRITE, string $prefix = &quot;&quot;): int</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>$array</code></strong>：要提取的关联数组，键成为变量名，值成为变量值。</li>
<li><strong><code>$flags</code></strong>（可选）：定义如何处理已有变量（后面详解）。</li>
<li><strong><code>$prefix</code></strong>（可选）：如果键是无效变量名，可以添加前缀。</li>
</ul>
<hr>
<h4 id="2-基本用法"><a href="#2-基本用法" class="headerlink" title="2. 基本用法"></a><strong>2. 基本用法</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$data = [</span><br><span class="line">    &quot;name&quot; =&gt; &quot;Darkxell&quot;,</span><br><span class="line">    &quot;age&quot; =&gt; 25,</span><br><span class="line">    &quot;language&quot; =&gt; &quot;PHP&quot;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">extract($data);</span><br><span class="line"></span><br><span class="line">echo $name;   // 输出: Darkxell</span><br><span class="line">echo $age;    // 输出: 25</span><br><span class="line">echo $language; // 输出: PHP</span><br></pre></td></tr></table></figure>

<p>这里，<code>extract($data)</code> 相当于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$name = &quot;Darkxell&quot;;</span><br><span class="line">$age = 25;</span><br><span class="line">$language = &quot;PHP&quot;;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-extract-的-flags-参数"><a href="#3-extract-的-flags-参数" class="headerlink" title="3. extract() 的 flags 参数"></a><strong>3. <code>extract()</code> 的 <code>flags</code> 参数</strong></h4><p><strong><code>$flags</code></strong> 参数决定如何处理数组中的变量名<strong>如果已经存在</strong>的情况：</p>
<ul>
<li><code>EXTR_OVERWRITE</code>（默认）：覆盖已存在的同名变量。</li>
<li><code>EXTR_SKIP</code>：跳过已有变量，不覆盖。</li>
<li><code>EXTR_PREFIX_SAME</code>：如果变量名已存在，加前缀（<code>$prefix</code>）。</li>
<li><code>EXTR_PREFIX_ALL</code>：所有变量都加前缀（无论是否冲突）。</li>
<li><code>EXTR_PREFIX_INVALID</code>：仅对无效变量名加前缀。</li>
<li><code>EXTR_IF_EXISTS</code>：仅覆盖已有变量，不创建新变量。</li>
<li><code>EXTR_PREFIX_IF_EXISTS</code>：仅对已有变量加前缀，不创建新变量。</li>
</ul>
<h5 id="示例-1：防止覆盖"><a href="#示例-1：防止覆盖" class="headerlink" title="示例 1：防止覆盖"></a><strong>示例 1：防止覆盖</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$data = [</span><br><span class="line">    &quot;name&quot; =&gt; &quot;Darkxell&quot;,</span><br><span class="line">    &quot;age&quot; =&gt; 25</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">$name = &quot;OriginalName&quot;; // 变量已存在</span><br><span class="line">extract($data, EXTR_SKIP);</span><br><span class="line">echo $name; // 仍然是 &quot;OriginalName&quot;，不会被覆盖</span><br></pre></td></tr></table></figure>

<h5 id="示例-2：使用前缀"><a href="#示例-2：使用前缀" class="headerlink" title="示例 2：使用前缀"></a><strong>示例 2：使用前缀</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$data = [</span><br><span class="line">    &quot;name&quot; =&gt; &quot;Darkxell&quot;,</span><br><span class="line">    &quot;age&quot; =&gt; 25</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">extract($data, EXTR_PREFIX_ALL, &quot;user&quot;);</span><br><span class="line"></span><br><span class="line">echo $user_name; // Darkxell</span><br><span class="line">echo $user_age;  // 25</span><br></pre></td></tr></table></figure>

<h5 id="示例-3：避免非法变量名"><a href="#示例-3：避免非法变量名" class="headerlink" title="示例 3：避免非法变量名"></a><strong>示例 3：避免非法变量名</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$data = [</span><br><span class="line">    &quot;123invalid&quot; =&gt; &quot;Hello&quot;,</span><br><span class="line">    &quot;valid_name&quot; =&gt; &quot;World&quot;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">extract($data, EXTR_PREFIX_INVALID, &quot;var&quot;);</span><br><span class="line">echo $var_123invalid; // Hello</span><br><span class="line">echo $valid_name;     // World</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-extract-在-CTF-和安全中的应用"><a href="#4-extract-在-CTF-和安全中的应用" class="headerlink" title="4. extract() 在 CTF 和安全中的应用"></a><strong>4. <code>extract()</code> 在 CTF 和安全中的应用</strong></h4><h5 id="（1）信息泄露"><a href="#（1）信息泄露" class="headerlink" title="（1）信息泄露"></a><strong>（1）信息泄露</strong></h5><p><code>extract()</code> 可能导致<strong>变量覆盖</strong>或<strong>信息泄露</strong>，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extract($_GET);</span><br><span class="line">echo $flag;</span><br></pre></td></tr></table></figure>

<p>如果 <code>GET</code> 传递：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?flag=CTF&#123;hidden_flag&#125;</span><br></pre></td></tr></table></figure>

<p>那么 <code>$flag</code> 变量就会被赋值，直接显示出 <code>CTF&#123;hidden_flag&#125;</code>。</p>
<h5 id="（2）变量覆盖漏洞"><a href="#（2）变量覆盖漏洞" class="headerlink" title="（2）变量覆盖漏洞"></a><strong>（2）变量覆盖漏洞</strong></h5><p>如果代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$admin = false;</span><br><span class="line">extract($_POST);</span><br><span class="line">if ($admin) &#123;</span><br><span class="line">    echo &quot;You are admin!&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>攻击者发送 <code>POST</code> 请求：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin=1</span><br></pre></td></tr></table></figure>

<p>则 <code>$admin</code> 被覆盖为 <code>1</code>，绕过了权限校验。</p>
<h5 id="（3）配合-GLOBALS-变量劫持"><a href="#（3）配合-GLOBALS-变量劫持" class="headerlink" title="（3）配合 GLOBALS 变量劫持"></a><strong>（3）配合 <code>GLOBALS</code> 变量劫持</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extract($_GET);</span><br><span class="line">$GLOBALS[&quot;flag&quot;] = &quot;CTF&#123;hidden_flag&#125;&quot;;</span><br></pre></td></tr></table></figure>

<p>GET 请求：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?flag=CTF&#123;hacked&#125;</span><br></pre></td></tr></table></figure>

<p>会导致 <code>flag</code> 变量被覆盖。</p>
<h3 id="compact"><a href="#compact" class="headerlink" title="compact()"></a>compact()</h3><p>如果 <code>extract()</code> 是<strong>数组转变量</strong>，那么 <code>compact()</code> 就是<strong>变量转数组</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$name = &quot;Darkxell&quot;;</span><br><span class="line">$age = 25;</span><br><span class="line">$data = compact(&quot;name&quot;, &quot;age&quot;);</span><br><span class="line"></span><br><span class="line">print_r($data);</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Array</span><br><span class="line">(</span><br><span class="line">    [name] =&gt; Darkxell</span><br><span class="line">    [age] =&gt; 25</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><code>extract()</code></th>
<th>从数组创建变量</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><code>compact()</code></th>
<th>从变量创建数组</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="assert-函数"><a href="#assert-函数" class="headerlink" title="assert() 函数"></a><code>assert()</code> 函数</h3><p> PHP 中，<code>assert()</code> 是一个内置函数，用于检查一个表达式是否为真。如果为真，则什么都不做；如果为假，则会抛出一个警告。</p>
<p>通常，<code>assert()</code> 用来进行调试，但是在某些情况下，<code>assert()</code> 也可以用来执行代码，这取决于它传递的参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert(expression);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>expression</code> 是需要检查的一个表达式。一般来说，<code>assert()</code> 会判断这个表达式是否为真。</li>
<li>如果表达式为 <code>false</code>，<code>assert()</code> 会触发一个警告并且停止执行（通常这是在开发环境中用于调试的工具）。</li>
</ul>
<ol start="2">
<li><strong>通过 <code>assert()</code> 执行代码</strong></li>
</ol>
<p>在某些情况下，<code>assert()</code> 也可以用来执行代码。如果传入给 <code>assert()</code> 的是一个可以作为 PHP 代码执行的字符串，它将会作为一段 PHP 代码执行。</p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert(&#x27;phpinfo();&#x27;);</span><br></pre></td></tr></table></figure>

<p>这将会执行 <code>phpinfo()</code> 函数，并显示 PHP 配置信息。</p>
<p><img src="/../picture/image-20250323111807538.png" alt="image-20250323111807538"></p>
<p>比如这个题里  我传入?$fl0g&#x3D;flag_give_me</p>
<p>因为server  就相当与传入了一个 $_GET[‘fl0g’]&#x3D;flag_give_me</p>
<p>但是现在还没有将flag_give_me真正储存到$fl0g这个变量里<br>所以我们就需要通过fun&#x3D;assert($a[0])   因为a&#x3D;server[‘argv’]  相当于传入了一个数组</p>
<p>a[0]就是第一个元素  $fl0g&#x3D;flag_give_me   而assert就会执行$f10g&#x3D;flag_give_me  这个php的有效代码<br>成功把flag_give_me储存到$f10g里</p>
<p>从而成功执行echo $f10g</p>
<h3 id="SERVER-‘QUERY-STRING’-SERVER-‘argv’"><a href="#SERVER-‘QUERY-STRING’-SERVER-‘argv’" class="headerlink" title="$_SERVER[‘QUERY_STRING’]   $_SERVER[‘argv’]"></a>$_SERVER[‘QUERY_STRING’]   $_SERVER[‘argv’]</h3><p><code>$_SERVER[&#39;QUERY_STRING&#39;]</code> 和 <code>$_SERVER[&#39;argv&#39;]</code> 都是 PHP 中常见的全局变量，但它们的使用场景和内容有所不同。我们来详细解释它们之间的区别：</p>
<ol>
<li><strong><code>$_SERVER[&#39;QUERY_STRING&#39;]</code></strong></li>
</ol>
<ul>
<li><p><strong>定义：</strong><br> <code>$_SERVER[&#39;QUERY_STRING&#39;]</code> 包含 URL 中 <code>?</code> 后面的部分，即查询字符串（query string）。查询字符串是 URL 中传递参数的一部分。例如，在 URL <code>http://example.com/index.php?a=1&amp;b=2</code> 中，<code>a=1&amp;b=2</code> 就是查询字符串。</p>
</li>
<li><p><strong>示例：</strong><br> 假设 URL 是 <code>http://example.com/index.php?user=admin&amp;role=admin</code>，那么：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $_SERVER[&#x27;QUERY_STRING&#x27;];</span><br></pre></td></tr></table></figure>

<p>输出将会是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user=admin&amp;role=admin</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>用途：</strong><br> 你通常使用 <code>$_SERVER[&#39;QUERY_STRING&#39;]</code> 来获取 URL 中 <code>?</code> 后面的所有参数及其值。它可以帮助你解析 URL 查询字符串，但它不会将这些参数转换为关联数组。你需要使用 <code>parse_str()</code> 等函数将查询字符串解析为 PHP 数组。</p>
</li>
</ul>
<ol start="2">
<li><strong><code>$_SERVER[&#39;argv&#39;]</code></strong></li>
</ol>
<ul>
<li><p><strong>定义：</strong><br> <code>$_SERVER[&#39;argv&#39;]</code> 包含通过命令行传递给 PHP 脚本的参数。也就是说，它用于 PHP 脚本在命令行模式下执行时，从命令行接收的参数。</p>
</li>
<li><p><strong>示例：</strong><br> 假设你在命令行中运行 PHP 脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php script.php arg1 arg2 arg3</span><br></pre></td></tr></table></figure>

<p>那么在脚本中，<code>$_SERVER[&#39;argv&#39;]</code> 将会是一个包含所有参数的数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print_r($_SERVER[&#x27;argv&#x27;]);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Array</span><br><span class="line">(</span><br><span class="line">    [0] =&gt; script.php</span><br><span class="line">    [1] =&gt; arg1</span><br><span class="line">    [2] =&gt; arg2</span><br><span class="line">    [3] =&gt; arg3</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>用途：</strong><br> <code>$_SERVER[&#39;argv&#39;]</code> 主要用于命令行界面的 PHP 脚本，允许开发者从命令行传递参数。它不是用于处理 HTTP 请求。</p>
</li>
</ul>
<h3 id="3-区别："><a href="#3-区别：" class="headerlink" title="3. 区别："></a>3. <strong>区别：</strong></h3><table>
<thead>
<tr>
<th>特性</th>
<th><code>$_SERVER[&#39;QUERY_STRING&#39;]</code></th>
<th><code>$_SERVER[&#39;argv&#39;]</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>来源</strong></td>
<td>从 URL 的查询字符串中获取参数，通常用于 HTTP 请求</td>
<td>从命令行中传递给 PHP 脚本的参数</td>
</tr>
<tr>
<td><strong>例子</strong></td>
<td><code>http://example.com/index.php?a=1&amp;b=2</code></td>
<td><code>php script.php arg1 arg2 arg3</code></td>
</tr>
<tr>
<td><strong>返回值</strong></td>
<td>查询字符串，格式为键值对（例如 <code>a=1&amp;b=2</code>）</td>
<td>包含命令行参数的数组（例如 <code>[&#39;script.php&#39;, &#39;arg1&#39;, &#39;arg2&#39;]</code>）</td>
</tr>
<tr>
<td><strong>用途</strong></td>
<td>用于 Web 请求中获取 URL 参数</td>
<td>用于命令行脚本传递参数</td>
</tr>
<tr>
<td><strong>可用性</strong></td>
<td>在 Web 环境中使用</td>
<td>仅在命令行环境中使用</td>
</tr>
</tbody></table>
<h3 id="4-代码示例对比："><a href="#4-代码示例对比：" class="headerlink" title="4. 代码示例对比："></a>4. <strong>代码示例对比：</strong></h3><ul>
<li><p><strong><code>$_SERVER[&#39;QUERY_STRING&#39;]</code>：</strong><br> 假设 URL 为 <code>http://example.com/index.php?a=1&amp;b=2</code>，你可以这样访问查询字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $_SERVER[&#x27;QUERY_STRING&#x27;];  // 输出: a=1&amp;b=2</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>$_SERVER[&#39;argv&#39;]</code>：</strong><br> 假设你在命令行中运行 PHP 脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php script.php arg1 arg2 arg3</span><br></pre></td></tr></table></figure>

<p>你可以访问命令行参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print_r($_SERVER[&#x27;argv&#x27;]);  // 输出: Array([0] =&gt; script.php, [1] =&gt; arg1, [2] =&gt; arg2, [3] =&gt; arg3)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-总结："><a href="#5-总结：" class="headerlink" title="5. 总结："></a>5. <strong>总结：</strong></h3><ul>
<li><strong><code>$_SERVER[&#39;QUERY_STRING&#39;]</code></strong> 是 Web 环境中的查询字符串，它包含了 URL 中 <code>?</code> 后的所有参数。常用于 Web 页面的请求中。</li>
<li><strong><code>$_SERVER[&#39;argv&#39;]</code></strong> 是命令行环境中的参数，包含了从命令行传递给 PHP 脚本的所有参数。常用于命令行模式下执行的 PHP 脚本。</li>
</ul>
<p>它们的主要区别在于来源和使用场景：<code>$_SERVER[&#39;QUERY_STRING&#39;]</code> 用于 Web 请求中的 URL 查询参数，而 <code>$_SERVER[&#39;argv&#39;]</code> 用于命令行中的参数。</p>
<h3 id="call-user-func"><a href="#call-user-func" class="headerlink" title="call_user_func"></a>call_user_func</h3><p>var_dump(call_user_func(call_user_func($f1,$f2)));<br>call_user_func($f1, $f2) 会尝试执行 $f1 所代表的函数，并将 $f2 作为参数传递给该函数。</p>
<p>如果 $f1 是一个有效的函数名，并且该函数能够接受 $f2 作为参数，call_user_func($f1, $f2) 会执行该函数。</p>
<p>结果会进一步传递给 var_dump() 进行输出。</p>
<p>外层的 <code>call_user_func</code></p>
<p>接下来，外层的 <code>call_user_func</code> 会接收到内层 <code>call_user_func</code> 返回的结果，并再次执行它。</p>
<p>假设内层的 <code>call_user_func</code> 返回的是 <code>&#39;HELLO&#39;</code>，那么：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call_user_func(&#x27;HELLO&#x27;);</span><br></pre></td></tr></table></figure>

<p>PHP 会尝试执行 <code>HELLO</code> 作为函数名。然而，<code>HELLO</code> 不是一个有效的函数名，因此会导致一个错误。</p>
<p>问题的核心</p>
<p>这里的问题是，<code>call_user_func(call_user_func($f1, $f2))</code> 看起来是一个嵌套调用，但由于内层 <code>call_user_func</code> 的返回值并不是一个有效的函数名，它会引发错误。你需要确保内层 <code>call_user_func</code> 返回的值实际上是一个有效的函数名。</p>
<h3 id="get-defined-vars-1"><a href="#get-defined-vars-1" class="headerlink" title="get_defined_vars"></a>get_defined_vars</h3><p><code>get_defined_vars()</code> 是 PHP 的一个内置函数，它返回当前作用域（或范围）内所有已定义的变量及其值。这个函数可以用于检查当前 PHP 脚本中定义了哪些变量，包括全局变量、局部变量以及通过 <code>$_GET</code>、<code>$_POST</code> 等超全局数组传递的变量。</p>
<h3 id="mt-rand-1-0x36D"><a href="#mt-rand-1-0x36D" class="headerlink" title="mt_rand(1,0x36D)"></a>mt_rand(1,0x36D)</h3><ul>
<li><code>mt_rand(min, max)</code> 是 <strong>Mersenne Twister 伪随机数生成器</strong>，用于生成 <code>min</code> 到 <code>max</code> 之间的随机整数（<strong>包含 <code>min</code> 和 <code>max</code></strong>）。</li>
<li><code>0x36D</code> 是一个 <strong>十六进制数</strong>，等于 <strong>十进制的 <code>877</code></strong>。</li>
</ul>
<h3 id="计算结果"><a href="#计算结果" class="headerlink" title="计算结果"></a><strong>计算结果</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mt_rand(1, 0x36D) === mt_rand(1, 877)</span><br></pre></td></tr></table></figure>

<p>这个函数会返回 <strong>1 到 877 之间的随机整数</strong>。</p>
<h3 id="URL-传参时的特殊字符处理规则（-绕过）"><a href="#URL-传参时的特殊字符处理规则（-绕过）" class="headerlink" title="URL 传参时的特殊字符处理规则（.绕过）"></a><strong>URL 传参时的特殊字符处理规则</strong>（.绕过）</h3><p>传上去的参数只会有数字 字母与下划线</p>
<ol>
<li><code>[ ]</code> → <strong>变成 <code>_</code></strong>（因为 PHP 解析时可能会把 <code>e[m.p]</code> 认为是数组）</li>
<li><code>.</code>  → <strong>变成 <code>_</code></strong>（因为 <code>.</code> 在 PHP 变量名中无效）   <strong><code>.</code> 只有在</strong> 顶级键 <strong>才会变成 <code>_</code></strong></li>
<li><code>-</code>  → <strong>不会被转换</strong>（可以作为数组键）</li>
<li>其他特殊字符（如 <code>@</code>, <code>#</code>, <code>*</code>, <code>+</code> 等）<strong>不会被解析成键名</strong>，但可以作为值</li>
</ol>
<h3 id="tee命令"><a href="#tee命令" class="headerlink" title="tee命令"></a>tee命令</h3><p>tee指令会从标准输入设备读取数据，将其内容输出到标准输出设备，同时保存成文件</p>
<p>比如 exec(ls &#x2F;|tee 1)  会将ls &#x2F; 列出的目录 保存到1文件中</p>
<p><strong>管道符 <code>|</code> 是在 Linux 和类 Unix 系统中用于连接多个命令的特殊符号，它的作用是将前一个命令的标准输出（stdout）作为下一个命令的标准输入（stdin）。</strong></p>
<h3 id="strripos"><a href="#strripos" class="headerlink" title="strripos()"></a>strripos()</h3><p><code>strripos()</code> 是 PHP 的一个函数，它用于查找字符串在另一个字符串中最后一次出现的位置（不区分大小写）。它返回的是子字符串的位置，如果没有找到，返回 <code>false</code>。</p>
<h4 id="strripos-函数的语法："><a href="#strripos-函数的语法：" class="headerlink" title="strripos() 函数的语法："></a><code>strripos()</code> 函数的语法：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strripos($haystack, $needle)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>$haystack</code>：要搜索的字符串（大字符串）。</li>
<li><code>$needle</code>：要查找的子字符串（小字符串）。</li>
<li>如果找到了，返回子字符串在大字符串中最后出现的位置（以 0 为起始索引）。如果没有找到，返回 <code>false</code>。</li>
</ul>
<p>web137</p>
<p><strong>call_user_func($_POST[‘ctfshow’]);</strong></p>
<p>ctfshow[0]&#x3D;ctfshow&amp;ctfshow[1]&#x3D;getFlag</p>
<p>在这种情况下，<code>$_POST[&#39;ctfshow&#39;]</code> 是一个数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$_POST[&#x27;ctfshow&#x27;] = array(0 =&gt; &#x27;ctfshow&#x27;, 1 =&gt; &#x27;getFlag&#x27;);</span><br></pre></td></tr></table></figure>

<p>这里，<code>$_POST[&#39;ctfshow&#39;]</code> 数组包含两个元素：<code>&#39;ctfshow&#39;</code> 和 <code>&#39;getFlag&#39;</code>。当 <code>call_user_func()</code> 被调用时，PHP 会解析数组并尝试将其作为方法调用。具体来说：</p>
<ul>
<li><code>$_POST[&#39;ctfshow&#39;][0]</code> 是 <code>&#39;ctfshow&#39;</code> 类。</li>
<li><code>$_POST[&#39;ctfshow&#39;][1]</code> 是 <code>&#39;getFlag&#39;</code> 方法。</li>
</ul>
<p>所以，<code>call_user_func($_POST[&#39;ctfshow&#39;])</code> 将等效于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctfshow::getFlag();</span><br></pre></td></tr></table></figure>

<p>web140</p>
<p>在 PHP 中，如果你将一个字符串与整数进行比较，PHP 会尝试将字符串转换为数值。</p>
<p><strong><code>usleep()</code> 函数</strong>:</p>
<p><code>usleep()</code> 是一个 PHP 函数，接受一个整数参数并使程序暂停一段时间（微秒）。</p>
<p>如果 <code>usleep()</code> 被传递 <code>null</code> 或无效参数时，通常 PHP 会抛出一个警告。但是有可能，在某些情况下（如 <code>null</code> 被转换为 <code>0</code>），<code>usleep()</code> 可能不抛出警告或 PHP 会以某种方式“静默”处理它。</p>
<h3 id="switch循环语句传参"><a href="#switch循环语句传参" class="headerlink" title="switch循环语句传参"></a>switch循环语句传参</h3><p>在 PHP 中，<code>switch</code> 语句的比较是通过 <strong>严格比较（&#x3D;&#x3D;）</strong> 来进行的。当你传递一个非数字字符串（例如 <code>&quot;flag&quot;</code>）时，PHP 会<strong>尝试将其转换为数字</strong>。这个转换过程有些特殊，通常会把任何非数字字符串转换为 <strong><code>0</code></strong>。</p>
<p><img src="/../picture/image-20250330103256994.png" alt="image-20250330103256994"></p>
